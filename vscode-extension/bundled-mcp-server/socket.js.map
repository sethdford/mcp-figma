{"version":3,"sources":["../src/socket.ts"],"sourcesContent":["import { createServer } from 'http';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { URL } from 'url';\n\n// Store clients by channel\nconst channels = new Map<string, Set<WebSocket>>();\n\nfunction handleConnection(ws: WebSocket) {\n  // Don't add to clients immediately - wait for channel join\n  console.log(\"New client connected\");\n\n  // Send welcome message to the new client\n  ws.send(JSON.stringify({\n    type: \"system\",\n    message: \"Please join a channel to start chatting\",\n  }));\n\n  ws.on('close', () => {\n    console.log(\"Client disconnected\");\n\n    // Remove client from their channel\n    channels.forEach((clients, channelName) => {\n      if (clients.has(ws)) {\n        clients.delete(ws);\n\n        // Notify other clients in same channel\n        clients.forEach((client) => {\n          if (client.readyState === WebSocket.OPEN) {\n            client.send(JSON.stringify({\n              type: \"system\",\n              message: \"A user has left the channel\",\n              channel: channelName\n            }));\n          }\n        });\n      }\n    });\n  });\n\n  ws.on('message', (message: Buffer) => {\n      try {\n      console.log(\"Received message from client:\", message.toString());\n      const data = JSON.parse(message.toString());\n\n        if (data.type === \"join\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"Channel name is required\"\n            }));\n            return;\n          }\n\n          // Create channel if it doesn't exist\n          if (!channels.has(channelName)) {\n            channels.set(channelName, new Set());\n          }\n\n          // Add client to channel\n          const channelClients = channels.get(channelName)!;\n          channelClients.add(ws);\n\n          // Notify client they joined successfully\n          ws.send(JSON.stringify({\n            type: \"system\",\n            message: `Joined channel: ${channelName}`,\n            channel: channelName\n          }));\n\n          console.log(\"Sending message to client:\", data.id);\n\n          ws.send(JSON.stringify({\n            type: \"system\",\n            message: {\n              id: data.id,\n              result: \"Connected to channel: \" + channelName,\n            },\n            channel: channelName\n          }));\n\n          // Notify other clients in channel\n          channelClients.forEach((client) => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n              client.send(JSON.stringify({\n                type: \"system\",\n                message: \"A new user has joined the channel\",\n                channel: channelName\n              }));\n            }\n          });\n          return;\n        }\n\n        // Handle regular messages\n        if (data.type === \"message\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"Channel name is required\"\n            }));\n            return;\n          }\n\n          const channelClients = channels.get(channelName);\n          if (!channelClients || !channelClients.has(ws)) {\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"You must join the channel first\"\n            }));\n            return;\n          }\n\n          // Broadcast to all clients in the channel\n          channelClients.forEach((client) => {\n            if (client.readyState === WebSocket.OPEN) {\n              console.log(\"Broadcasting message to client:\", data.message);\n              client.send(JSON.stringify({\n                type: \"broadcast\",\n                message: data.message,\n                sender: client === ws ? \"You\" : \"User\",\n                channel: channelName\n              }));\n            }\n          });\n        }\n      } catch (err) {\n        console.error(\"Error handling message:\", err);\n      }\n  });\n}\n\n// Create HTTP server\nconst server = createServer((req, res) => {\n  // Handle CORS preflight\n  if (req.method === \"OPTIONS\") {\n    res.writeHead(204, {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n    });\n    res.end();\n    return;\n  }\n\n  // Return response for non-WebSocket requests\n  res.writeHead(200, {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Content-Type\": \"text/plain\"\n  });\n  res.end(\"WebSocket server running\");\n});\n\n// Create WebSocket server\nconst wss = new WebSocketServer({ \n  server,\n  perMessageDeflate: false\n});\n\nwss.on('connection', handleConnection);\n\nconst PORT = process.env.FIGMA_WEBSOCKET_PORT ? parseInt(process.env.FIGMA_WEBSOCKET_PORT, 10) : 3055;\nconst HOST = process.env.FIGMA_WEBSOCKET_HOST || \"localhost\";\n\nserver.listen(PORT, HOST, () => {\n  console.log(`WebSocket server started on host ${HOST} port ${PORT}`);\n});\n"],"mappings":"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","names":[]}